// WriteGeo.h
// Copyright (c) 2009 The Foundry Visionmongers Ltd.  All Rights Reserved.

#ifndef DDImage_WriteGeo_h
#define DDImage_WriteGeo_h

#include "DDImage/GeoOp.h"
#include "DDImage/FileIop.h"
#include "DDImage/Executable.h"

namespace DD
{
  namespace Image
  {

    class GeoWriter;

    /*! \class DD::Image::WriteGeo
        This is a base class for a file writer.

        All the work is done by the various subclasses of GeoWriter.
        WriteGeo just chooses what subclass to instantiate and returns the
        output from it, and correctly destroys and instantiates new ones
        as needed.

        Calling Op::execute() initiates writing the file.
     */
    class DDImage_API WriteGeo : public GeoOp, public FileOp, public Executable
    {
      GeoWriter* _writer;
      const void* _writer_type; // points at a Writer::Description
      const char* _file_type_knob;
      const char* _filename;
      const char* _fname;
      int _frame;
      
      /// views to write out according to the knobs
      std::set<int> _views;

      GeoWriter* getWriter(const char* filename);

      virtual Op* op() {
        return this;
      }

    protected:
      /*virtual*/ void _validate(bool);

      /*! Closes file that may be left open. That should not happen, though. */
      /*virtual*/ void _close();

    public:
      WriteGeo(Node * node);

      /*! calls _close() */
      ~WriteGeo();
      Executable* executable() { return this; }
      virtual bool isWrite() const { return true; }
      virtual void beginExecuting();

      /*! call finish() on the writer if it is writing an animation file.
       */
      virtual void endExecuting();

      /// Returns WriteMany if the Writer object asks for more than one
      /// in Writer::split_input(), indicating that (most likely) more than
      /// one view is wanted.
      /// Returns WriteOne otherwise, indicating it is a waste of time to
      /// call this with different views. Nuke will detect if the filename
      /// changes when the view changes and will call this multiple times with
      /// different filenames, otherwise complain if the user asks for more
      /// than one view to execute.
      virtual ExecMode execViewMode();

      /*! Returns WriteMany if the Writer object returns true for animation().
          Returns WriteOne otherwise, indicating it is a waste of time to
          call this with different frames. Nuke will detect if the filename
          changes when the frame changes and will call this multiple times with
          different filenames, otherwise complain if the user asks for more
          than one frame to execute.
      */
      virtual ExecMode execFrameMode();
      const std::set<int>& views() { return _views; }

      /*! Calls Writer::split_input(). 
      */
      virtual int split_input(int i) const;

      void execute();

      virtual FileHandler* handler() const;

      const char* filename() const { return _fname ? _fname : _filename; }
      const char* getFilename() const { return filename(); }
      const char* fname() const { return _fname; }
      void filename(const char* f) { _filename = f; }

      /*
         Return an array of names of file types known about.
         This is generated by searching the pluigin directories for any
         plugins called "*Writer.plugin_ext". The first location in the
         array is a blank string for 'unknown' and the array is NULL-terminated.
       */
      static const char* const* file_types();

      /*!
         Return the type of file this will write. This is set by set_file_type()
         or set_file_type_from_filename() or by validate() if neither of these
         is done. This is actually the null-sepearted list of names from the
         DD::Image::Writer::Description object.
       */
      virtual const char* file_type() const;

      /*!
         Set the type of file the Writer will write. The type is a string like
         "cin" or "jpeg". Returns true if the new type is different than the
         previous one. Notice that if the type changes all settings on
         Writer-specific knobs are lost.

         If this type is not found or is zero then file_type() is set to zero.
         If the node is then executed it will attempt to figure out the type
         from the filename, and if that fails it will cause an error.

         file_types() returns a list of available names. You may also be able
         to set other names like "sgi16" that are not in this list, these
         typically initialize some knobs to non-default values.
       */
      bool set_file_type(const char*);

      /*!
         If the filename has "name:" near the start, try using that to set
         the file type. If that fails, try using the file extension.
         This is automatically done by execute() and validate() if this
         or set_file_type() has not been called.
       */
      bool set_file_type_from_filename(Knob* knob = nullptr);


      /*! Calls Op::error(), but prefixes "filename: " to the message. */
      void internalError(const char* fmt, ...);

      void filetype_knobs(Knob_Callback f);
      /*virtual*/ void knobs(Knob_Callback);
      /*virtual*/ int knob_changed(Knob*);
      /*virtual*/ const char* Class() const;
      /*virtual*/ const char* node_help() const;
      static const Description d;
    };

  }
}

#endif

// Copyright (c) 2009 The Foundry Visionmongers Ltd.  All Rights Reserved.
